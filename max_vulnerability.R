#The following script was generated to calculate maximum network vulnerability.
#The maximum vulnerability value indicates the single most critical node in the group. This node has the highest impact on the networkâ€™s efficiency when removed.
#Comparing these max values across groups and networks can help identify which groups or networks are most vulnerable to disruptions.

#networks are imported as tab generated files

setwd("/Users/networks") #this corresponds to the location of your network's files

library(igraph)
#import network edge data
edge_lists.T1 <- as.data.frame(read.table("allT1nonTrare002_0.96_edge_attribute_idirect.txt", header = T, as.is = T, sep="\t"))
edge_lists.T3 <- as.data.frame(read.table("allT3nonTrare002_0.96_edge_attribute_idirect.txt", header = T, as.is = T, sep="\t"))
edge_lists.T4 <- as.data.frame(read.table("allT4nonTrare002_0.94_edge_attribute_idirect.txt", header = T, as.is = T, sep="\t"))

#declare networks
network1 <- graph_from_edgelist(as.matrix(edge_lists.T1[, c("taxa1", "taxa2")]), directed = FALSE)
network2 <-graph_from_edgelist(as.matrix(edge_lists.T3[, c("taxa1", "taxa2")]), directed = FALSE)
network3 <-graph_from_edgelist(as.matrix(edge_lists.T4[, c("taxa1", "taxa2")]), directed = FALSE)

# Function to remove nodes with degree zero (isolated nodes)
remove_zero_degree_nodes <- function(graph) {
  zero_degree_nodes <- V(graph)[degree(graph) == 0]  # Identify nodes with degree 0
  graph <- delete_vertices(graph, zero_degree_nodes)  # Remove nodes
  return(graph)
}

# Apply the function to each network
network1 <- remove_zero_degree_nodes(network1)
network2 <- remove_zero_degree_nodes(network2)
network3 <- remove_zero_degree_nodes(network3)


library(igraph)

# Function to calculate global efficiency of a graph
calculate_global_efficiency <- function(graph) {
  distances <- distances(graph)  # Compute shortest paths
  distances[distances == 0] <- Inf  # Replace zero distances (self-loops) with infinity
  efficiency <- sum(1 / distances[distances != Inf]) / (vcount(graph) * (vcount(graph) - 1))
  return(efficiency)
}

# Function to calculate node vulnerabilities
calculate_node_vulnerability <- function(graph) {
  global_efficiency <- calculate_global_efficiency(graph)  # Global efficiency of original graph
  
  # Compute vulnerability for each node
  vulnerabilities <- sapply(V(graph), function(node) {
    g_removed <- delete_vertices(graph, node)  # Remove node
    reduced_efficiency <- calculate_global_efficiency(g_removed)  # Efficiency of reduced graph
    vulnerability <- (global_efficiency - reduced_efficiency) / global_efficiency
    return(vulnerability)
  })
  
  return(vulnerabilities)
}

# Calculate vulnerabilities for each network
vulnerability_network1 <- calculate_node_vulnerability(network1)
vulnerability_network2 <- calculate_node_vulnerability(network2)
vulnerability_network3 <- calculate_node_vulnerability(network3)


# Combine results into a data frame 
vulnerability_results <- data.frame(
  Network = rep(c("Network1", "Network2", "Network3"), 
                times = c(vcount(network1), vcount(network2), vcount(network3))),
  Node = c(V(network1)$name, V(network2)$name, V(network3)$name),
  Vulnerability = c(vulnerability_network1, vulnerability_network2, vulnerability_network3)
)

vulnerability_results


library(dplyr)
# Summary statistics for each network, get the max, mean and sd for vulnerability per network
network_vulnerability_summary <- vulnerability_results %>%
  group_by(Network) %>%
  summarise(
    Max_Vulnerability = max(Vulnerability, na.rm = TRUE),
    Mean_Vulnerability = mean(Vulnerability, na.rm = TRUE),
    SD_Vulnerability = sd(Vulnerability, na.rm = TRUE)
  )

print(network_vulnerability_summary)

write.csv(network_vulnerability_summary, "vulnerability_results_summary.csv")
